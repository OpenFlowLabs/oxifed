// Code generated by Prisma Client Rust. DO NOT EDIT

pub static DATAMODEL_STR: &'static str =
    include_str!("/Users/toasty/ws/oxifed/prisma/schema.prisma");
static DATABASE_STR: &'static str = "mongodb";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder()
        .with_url(url.to_string())
        .build()
        .await
}
pub mod domain {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Domain";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod dns_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "dnsName";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDnsName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::DnsName(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::DnsName(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::DnsNameEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            DnsName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DnsName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DnsName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod actors {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "actors";
        pub struct Fetch(pub actor::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<actor::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: actor::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: actor::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Actors(v)
            }
        }
        pub fn fetch(params: Vec<actor::WhereParam>) -> Fetch {
            Fetch(actor::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<actor::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectActors(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<actor::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<actor::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectActors(params)
        }
        pub fn set(params: Vec<actor::UniqueWhereParam>) -> SetParam {
            SetParam::SetActors(params)
        }
        pub fn some(value: Vec<actor::WhereParam>) -> WhereParam {
            WhereParam::ActorsSome(value)
        }
        pub fn every(value: Vec<actor::WhereParam>) -> WhereParam {
            WhereParam::ActorsEvery(value)
        }
        pub fn none(value: Vec<actor::WhereParam>) -> WhereParam {
            WhereParam::ActorsNone(value)
        }
        pub enum Include {
            Select(actor::ManyArgs, Vec<actor::SelectParam>),
            Include(actor::ManyArgs, Vec<actor::IncludeParam>),
            Fetch(actor::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Actors(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <actor::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <actor::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: actor::ManyArgs,
                nested_selections: Vec<actor::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: actor::ManyArgs,
                nested_selections: Vec<actor::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(actor::ManyArgs, Vec<actor::SelectParam>),
            Include(actor::ManyArgs, Vec<actor::IncludeParam>),
            Fetch(actor::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Actors(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <actor::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: actor::ManyArgs,
                nested_selections: Vec<actor::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: actor::ManyArgs,
                nested_selections: Vec<actor::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod applications {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "applications";
        pub struct Set(pub Vec<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetApplications(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Applications(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Applications(direction)
        }
        pub fn equals(value: Vec<String>) -> WhereParam {
            WhereParam::Applications(_prisma::read_filters::StringListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringListFilter,
            Applications,
            {
                fn has(_: Option<String>) -> Has;
                fn has_every(_: Vec<String>) -> HasEvery;
                fn has_some(_: Vec<String>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<String>) -> SetParam {
            SetParam::PushApplications(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Applications(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Applications(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(dns_name: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
        (dns_name, _params)
    }
    pub fn create_unchecked(dns_name: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
        (dns_name, _params)
    }
    #[macro_export]
    macro_rules ! _select_domain { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: domain :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: domain :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: domain :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: domain :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: domain :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: domain :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , dns_name , actors , applications } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: domain :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: domain :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: domain :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: domain :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: domain :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: domain :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "dnsName" , "actors" , "applications"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: domain :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; dns_name) => { String } ; (@ field_type ; actors : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < actors :: Data > } ; (@ field_type ; actors) => { Vec < crate :: prisma :: actor :: Data > } ; (@ field_type ; applications) => { Vec < String > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Domain" , available relations are "id, dns_name, actors, applications")) } ; (@ field_module ; actors : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: actor :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: domain :: SelectParam > :: into (crate :: prisma :: domain :: id :: Select) } ; (@ selection_field_to_selection_param ; dns_name) => { Into :: < crate :: prisma :: domain :: SelectParam > :: into (crate :: prisma :: domain :: dns_name :: Select) } ; (@ selection_field_to_selection_param ; actors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: domain :: SelectParam > :: into (crate :: prisma :: domain :: actors :: Select :: $ selection_mode (crate :: prisma :: actor :: ManyArgs :: new (crate :: prisma :: actor :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: actor :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; actors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: domain :: SelectParam > :: into (crate :: prisma :: domain :: actors :: Select :: Fetch (crate :: prisma :: actor :: ManyArgs :: new (crate :: prisma :: actor :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; applications) => { Into :: < crate :: prisma :: domain :: SelectParam > :: into (crate :: prisma :: domain :: applications :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: domain :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; dns_name) => { "dnsName" } ; (@ field_serde_name ; actors) => { "actors" } ; (@ field_serde_name ; applications) => { "applications" } ; }
    pub use _select_domain as select;
    pub enum SelectParam {
        Id(id::Select),
        DnsName(dns_name::Select),
        Actors(actors::Select),
        Applications(applications::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::DnsName(data) => data.to_selection(),
                Self::Actors(data) => data.to_selection(),
                Self::Applications(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_domain { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: domain :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: domain :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: domain :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: domain :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: domain :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: domain :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: domain :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: domain :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { actors } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub dns_name : String , pub applications : Vec < String > , $ (pub $ field : crate :: prisma :: domain :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (dns_name) , stringify ! (applications)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: domain :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: domain :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: domain :: dns_name :: NAME , & self . dns_name) ? ; state . serialize_field (crate :: prisma :: domain :: applications :: NAME , & self . applications) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , dns_name , applications } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: domain :: $ field :: NAME) , + , crate :: prisma :: domain :: id :: NAME , crate :: prisma :: domain :: dns_name :: NAME , crate :: prisma :: domain :: applications :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: domain :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: domain :: id :: NAME => Ok (Field :: id) , crate :: prisma :: domain :: dns_name :: NAME => Ok (Field :: dns_name) , crate :: prisma :: domain :: applications :: NAME => Ok (Field :: applications) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut dns_name = None ; let mut applications = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: domain :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: dns_name => { if dns_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: domain :: dns_name :: NAME)) ; } dns_name = Some (map . next_value () ?) ; } Field :: applications => { if applications . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: domain :: applications :: NAME)) ; } applications = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: domain :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: domain :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: domain :: id :: NAME)) ? ; let dns_name = dns_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: domain :: dns_name :: NAME)) ? ; let applications = applications . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: domain :: applications :: NAME)) ? ; Ok (Data { id , dns_name , applications , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "dnsName" , "actors" , "applications"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: domain :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; actors : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < actors :: Data > } ; (@ field_type ; actors) => { Vec < crate :: prisma :: actor :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Domain" , available relations are "actors")) } ; (@ field_module ; actors : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: actor :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; actors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: domain :: IncludeParam > :: into (crate :: prisma :: domain :: actors :: Include :: $ selection_mode (crate :: prisma :: actor :: ManyArgs :: new (crate :: prisma :: actor :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: actor :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; actors $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: domain :: IncludeParam > :: into (crate :: prisma :: domain :: actors :: Include :: Fetch (crate :: prisma :: actor :: ManyArgs :: new (crate :: prisma :: actor :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: domain :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; dns_name) => { "dnsName" } ; (@ field_serde_name ; actors) => { "actors" } ; (@ field_serde_name ; applications) => { "applications" } ; }
    pub use _include_domain as include;
    pub enum IncludeParam {
        Id(id::Include),
        DnsName(dns_name::Include),
        Actors(actors::Include),
        Applications(applications::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::DnsName(data) => data.to_selection(),
                Self::Actors(data) => data.to_selection(),
                Self::Applications(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_domain { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: domain struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "dnsName")] pub dns_name : String , # [serde (rename = "applications")] pub applications : Vec < String > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_domain as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "dnsName")]
        pub dns_name: String,
        #[serde(rename = "actors")]
        pub actors: Option<Vec<super::actor::Data>>,
        #[serde(rename = "applications")]
        pub applications: Vec<String>,
    }
    impl Data {
        pub fn actors(
            &self,
        ) -> Result<&Vec<super::actor::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.actors
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(actors),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Actors(super::actor::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Actors(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: actor :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        actors::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetDnsName(String),
        ConnectActors(Vec<super::actor::UniqueWhereParam>),
        DisconnectActors(Vec<super::actor::UniqueWhereParam>),
        SetActors(Vec<super::actor::UniqueWhereParam>),
        SetApplications(Vec<String>),
        PushApplications(Vec<String>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetDnsName(value) => (
                    dns_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectActors(where_params) => (
                    actors::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::actor::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectActors(where_params) => (
                    actors::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::actor::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetActors(where_params) => (
                    actors::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::actor::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetApplications(value) => (
                    applications::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .collect(),
                    ),
                ),
                SetParam::PushApplications(value) => (
                    applications::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        DnsName(String),
        Applications(Vec<String>),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::DnsName(value) => Self::SetDnsName(value),
                UncheckedSetParam::Applications(value) => Self::SetApplications(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        DnsName(::prisma_client_rust::Direction),
        Applications(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::DnsName(direction) => (
                    dns_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Applications(direction) => (
                    applications::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        DnsName(_prisma::read_filters::StringFilter),
        ActorsSome(Vec<super::actor::WhereParam>),
        ActorsEvery(Vec<super::actor::WhereParam>),
        ActorsNone(Vec<super::actor::WhereParam>),
        Applications(_prisma::read_filters::StringListFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::DnsName(value) => (dns_name::NAME, value.into()),
                Self::ActorsSome(where_params) => (
                    actors::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActorsEvery(where_params) => (
                    actors::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActorsNone(where_params) => (
                    actors::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::Applications(value) => (applications::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        DnsNameEquals(String),
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::DnsNameEquals(value) => {
                    Self::DnsName(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(dns_name::NAME),
                ::prisma_client_rust::sel(applications::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, dns_name: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.extend([dns_name::set(dns_name)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            dns_name: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([dns_name::set(dns_name)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(dns_name, mut _params)| {
                    _params.extend([dns_name::set(dns_name)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (dns_name, mut _params): (String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([dns_name::set(dns_name)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod actor {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Actor";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod display_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "displayName";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDisplayName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::DisplayName(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::DisplayName(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DisplayName(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            DisplayName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DisplayName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DisplayName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod domain {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "domain";
        pub struct Fetch(pub domain::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<domain::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Domain(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(domain::UniqueArgs::new())
        }
        pub struct Connect(domain::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectDomain(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: domain::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<domain::WhereParam>) -> WhereParam {
            WhereParam::DomainIs(value)
        }
        pub fn is_not(value: Vec<domain::WhereParam>) -> WhereParam {
            WhereParam::DomainIsNot(value)
        }
        pub enum Include {
            Select(Vec<domain::SelectParam>),
            Include(Vec<domain::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Domain(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <domain::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <domain::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("domain", None, [], selections)
            }
            pub fn select(nested_selections: Vec<domain::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<domain::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<domain::SelectParam>),
            Include(Vec<domain::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Domain(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <domain::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("domain", None, [], selections)
            }
            pub fn select(nested_selections: Vec<domain::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<domain::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod domain_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "domainId";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDomainId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::DomainId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::DomainId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DomainId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            DomainId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DomainId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DomainId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod notes {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "notes";
        pub struct Fetch(pub note::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<note::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: note::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: note::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Notes(v)
            }
        }
        pub fn fetch(params: Vec<note::WhereParam>) -> Fetch {
            Fetch(note::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<note::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectNotes(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<note::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<note::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectNotes(params)
        }
        pub fn set(params: Vec<note::UniqueWhereParam>) -> SetParam {
            SetParam::SetNotes(params)
        }
        pub fn some(value: Vec<note::WhereParam>) -> WhereParam {
            WhereParam::NotesSome(value)
        }
        pub fn every(value: Vec<note::WhereParam>) -> WhereParam {
            WhereParam::NotesEvery(value)
        }
        pub fn none(value: Vec<note::WhereParam>) -> WhereParam {
            WhereParam::NotesNone(value)
        }
        pub enum Include {
            Select(note::ManyArgs, Vec<note::SelectParam>),
            Include(note::ManyArgs, Vec<note::IncludeParam>),
            Fetch(note::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Notes(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <note::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <note::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: note::ManyArgs, nested_selections: Vec<note::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: note::ManyArgs,
                nested_selections: Vec<note::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(note::ManyArgs, Vec<note::SelectParam>),
            Include(note::ManyArgs, Vec<note::IncludeParam>),
            Fetch(note::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Notes(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <note::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: note::ManyArgs, nested_selections: Vec<note::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: note::ManyArgs,
                nested_selections: Vec<note::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        display_name: String,
        domain: super::domain::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (String, super::domain::UniqueWhereParam, Vec<SetParam>) {
        (display_name, domain, _params)
    }
    pub fn create_unchecked(
        display_name: String,
        domain_id: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (display_name, domain_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_actor { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: actor :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: actor :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: actor :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: actor :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: actor :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: actor :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , display_name , domain , domain_id , notes } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: actor :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: actor :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: actor :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: actor :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: actor :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: actor :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "displayName" , "domain" , "domainId" , "notes"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: actor :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; display_name) => { String } ; (@ field_type ; domain : $ selection_mode : ident { $ ($ selections : tt) + }) => { domain :: Data } ; (@ field_type ; domain) => { crate :: prisma :: domain :: Data } ; (@ field_type ; domain_id) => { String } ; (@ field_type ; notes : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < notes :: Data > } ; (@ field_type ; notes) => { Vec < crate :: prisma :: note :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Actor" , available relations are "id, display_name, domain, domain_id, notes")) } ; (@ field_module ; domain : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: domain :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; notes : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: note :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: actor :: SelectParam > :: into (crate :: prisma :: actor :: id :: Select) } ; (@ selection_field_to_selection_param ; display_name) => { Into :: < crate :: prisma :: actor :: SelectParam > :: into (crate :: prisma :: actor :: display_name :: Select) } ; (@ selection_field_to_selection_param ; domain $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: actor :: SelectParam > :: into (crate :: prisma :: actor :: domain :: Select :: $ selection_mode (crate :: prisma :: domain :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; domain $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: actor :: SelectParam > :: into (crate :: prisma :: actor :: domain :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; domain_id) => { Into :: < crate :: prisma :: actor :: SelectParam > :: into (crate :: prisma :: actor :: domain_id :: Select) } ; (@ selection_field_to_selection_param ; notes $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: actor :: SelectParam > :: into (crate :: prisma :: actor :: notes :: Select :: $ selection_mode (crate :: prisma :: note :: ManyArgs :: new (crate :: prisma :: note :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: note :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; notes $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: actor :: SelectParam > :: into (crate :: prisma :: actor :: notes :: Select :: Fetch (crate :: prisma :: note :: ManyArgs :: new (crate :: prisma :: note :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: actor :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; display_name) => { "displayName" } ; (@ field_serde_name ; domain) => { "domain" } ; (@ field_serde_name ; domain_id) => { "domainId" } ; (@ field_serde_name ; notes) => { "notes" } ; }
    pub use _select_actor as select;
    pub enum SelectParam {
        Id(id::Select),
        DisplayName(display_name::Select),
        Domain(domain::Select),
        DomainId(domain_id::Select),
        Notes(notes::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::DisplayName(data) => data.to_selection(),
                Self::Domain(data) => data.to_selection(),
                Self::DomainId(data) => data.to_selection(),
                Self::Notes(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_actor { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: actor :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: actor :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: actor :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: actor :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: actor :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: actor :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: actor :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: actor :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { domain , notes } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub display_name : String , pub domain_id : String , $ (pub $ field : crate :: prisma :: actor :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (display_name) , stringify ! (domain_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: actor :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: actor :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: actor :: display_name :: NAME , & self . display_name) ? ; state . serialize_field (crate :: prisma :: actor :: domain_id :: NAME , & self . domain_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , display_name , domain_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: actor :: $ field :: NAME) , + , crate :: prisma :: actor :: id :: NAME , crate :: prisma :: actor :: display_name :: NAME , crate :: prisma :: actor :: domain_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: actor :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: actor :: id :: NAME => Ok (Field :: id) , crate :: prisma :: actor :: display_name :: NAME => Ok (Field :: display_name) , crate :: prisma :: actor :: domain_id :: NAME => Ok (Field :: domain_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut display_name = None ; let mut domain_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: actor :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: display_name => { if display_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: actor :: display_name :: NAME)) ; } display_name = Some (map . next_value () ?) ; } Field :: domain_id => { if domain_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: actor :: domain_id :: NAME)) ; } domain_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: actor :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: actor :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: actor :: id :: NAME)) ? ; let display_name = display_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: actor :: display_name :: NAME)) ? ; let domain_id = domain_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: actor :: domain_id :: NAME)) ? ; Ok (Data { id , display_name , domain_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "displayName" , "domain" , "domainId" , "notes"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: actor :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; domain : $ selection_mode : ident { $ ($ selections : tt) + }) => { domain :: Data } ; (@ field_type ; domain) => { crate :: prisma :: domain :: Data } ; (@ field_type ; notes : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < notes :: Data > } ; (@ field_type ; notes) => { Vec < crate :: prisma :: note :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Actor" , available relations are "domain, notes")) } ; (@ field_module ; domain : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: domain :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; notes : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: note :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; domain $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: actor :: IncludeParam > :: into (crate :: prisma :: actor :: domain :: Include :: $ selection_mode (crate :: prisma :: domain :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; domain $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: actor :: IncludeParam > :: into (crate :: prisma :: actor :: domain :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; notes $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: actor :: IncludeParam > :: into (crate :: prisma :: actor :: notes :: Include :: $ selection_mode (crate :: prisma :: note :: ManyArgs :: new (crate :: prisma :: note :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: note :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; notes $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: actor :: IncludeParam > :: into (crate :: prisma :: actor :: notes :: Include :: Fetch (crate :: prisma :: note :: ManyArgs :: new (crate :: prisma :: note :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: actor :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; display_name) => { "displayName" } ; (@ field_serde_name ; domain) => { "domain" } ; (@ field_serde_name ; domain_id) => { "domainId" } ; (@ field_serde_name ; notes) => { "notes" } ; }
    pub use _include_actor as include;
    pub enum IncludeParam {
        Id(id::Include),
        DisplayName(display_name::Include),
        Domain(domain::Include),
        DomainId(domain_id::Include),
        Notes(notes::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::DisplayName(data) => data.to_selection(),
                Self::Domain(data) => data.to_selection(),
                Self::DomainId(data) => data.to_selection(),
                Self::Notes(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_actor { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: actor struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "displayName")] pub display_name : String , # [serde (rename = "domainId")] pub domain_id : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_actor as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "displayName")]
        pub display_name: String,
        #[serde(rename = "domain")]
        pub domain: Option<Box<super::domain::Data>>,
        #[serde(rename = "domainId")]
        pub domain_id: String,
        #[serde(rename = "notes")]
        pub notes: Option<Vec<super::note::Data>>,
    }
    impl Data {
        pub fn domain(
            &self,
        ) -> Result<&super::domain::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.domain
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(domain),
                ))
                .map(|v| v.as_ref())
        }
        pub fn notes(
            &self,
        ) -> Result<&Vec<super::note::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.notes
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(notes),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Domain(super::domain::UniqueArgs),
        Notes(super::note::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Domain(args) => {
                    let mut selections = < super :: domain :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(domain::NAME, None, [], selections)
                }
                Self::Notes(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(
                        <super::note::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    );
                    ::prisma_client_rust::Selection::new(
                        notes::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetDisplayName(String),
        ConnectDomain(super::domain::UniqueWhereParam),
        SetDomainId(String),
        ConnectNotes(Vec<super::note::UniqueWhereParam>),
        DisconnectNotes(Vec<super::note::UniqueWhereParam>),
        SetNotes(Vec<super::note::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetDisplayName(value) => (
                    display_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectDomain(where_param) => (
                    domain::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::domain::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetDomainId(value) => (
                    domain_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectNotes(where_params) => (
                    notes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::note::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectNotes(where_params) => (
                    notes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::note::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetNotes(where_params) => (
                    notes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::note::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        DisplayName(String),
        DomainId(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::DisplayName(value) => Self::SetDisplayName(value),
                UncheckedSetParam::DomainId(value) => Self::SetDomainId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        DisplayName(::prisma_client_rust::Direction),
        DomainId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::DisplayName(direction) => (
                    display_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::DomainId(direction) => (
                    domain_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        DisplayName(_prisma::read_filters::StringFilter),
        DomainIs(Vec<super::domain::WhereParam>),
        DomainIsNot(Vec<super::domain::WhereParam>),
        DomainId(_prisma::read_filters::StringFilter),
        NotesSome(Vec<super::note::WhereParam>),
        NotesEvery(Vec<super::note::WhereParam>),
        NotesNone(Vec<super::note::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::DisplayName(value) => (display_name::NAME, value.into()),
                Self::DomainIs(where_params) => (
                    domain::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DomainIsNot(where_params) => (
                    domain::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DomainId(value) => (domain_id::NAME, value.into()),
                Self::NotesSome(where_params) => (
                    notes::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NotesEvery(where_params) => (
                    notes::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NotesNone(where_params) => (
                    notes::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(display_name::NAME),
                ::prisma_client_rust::sel(domain_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            display_name: String,
            domain: super::domain::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([display_name::set(display_name), domain::connect(domain)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            display_name: String,
            domain_id: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([display_name::set(display_name), domain_id::set(domain_id)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(String, String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(display_name, domain_id, mut _params)| {
                    _params.extend([display_name::set(display_name), domain_id::set(domain_id)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (display_name, domain, mut _params): (
                String,
                super::domain::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([display_name::set(display_name), domain::connect(domain)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod note {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Note";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod body {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "body";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBody(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Body(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Body(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Body(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Body, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Body(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Body(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod body_html {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "bodyHtml";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBodyHtml(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::BodyHtml(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BodyHtml(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::BodyHtml(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            BodyHtml,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::BodyHtml(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::BodyHtml(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod author {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "author";
        pub struct Fetch(pub actor::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<actor::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Author(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(actor::UniqueArgs::new())
        }
        pub struct Connect(actor::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectAuthor(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: actor::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<actor::WhereParam>) -> WhereParam {
            WhereParam::AuthorIs(value)
        }
        pub fn is_not(value: Vec<actor::WhereParam>) -> WhereParam {
            WhereParam::AuthorIsNot(value)
        }
        pub enum Include {
            Select(Vec<actor::SelectParam>),
            Include(Vec<actor::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Author(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <actor::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <actor::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("author", None, [], selections)
            }
            pub fn select(nested_selections: Vec<actor::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<actor::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<actor::SelectParam>),
            Include(Vec<actor::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Author(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <actor::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("author", None, [], selections)
            }
            pub fn select(nested_selections: Vec<actor::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<actor::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod author_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "authorId";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetAuthorId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::AuthorId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::AuthorId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::AuthorId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            AuthorId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AuthorId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AuthorId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod parent_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "parentId";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetParentId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ParentId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ParentId(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ParentId(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            ParentId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
                fn is_set(_: bool) -> IsSet;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ParentId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ParentId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod parent {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "parent";
        pub struct Fetch(pub note::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<note::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Parent(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(note::UniqueArgs::new())
        }
        pub struct Connect(note::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectParent(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: note::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectParent
        }
        pub fn is_null() -> WhereParam {
            WhereParam::ParentIsNull
        }
        pub fn is(value: Vec<note::WhereParam>) -> WhereParam {
            WhereParam::ParentIs(value)
        }
        pub fn is_not(value: Vec<note::WhereParam>) -> WhereParam {
            WhereParam::ParentIsNot(value)
        }
        pub enum Include {
            Select(Vec<note::SelectParam>),
            Include(Vec<note::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Parent(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <note::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <note::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("parent", None, [], selections)
            }
            pub fn select(nested_selections: Vec<note::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<note::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<note::SelectParam>),
            Include(Vec<note::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Parent(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <note::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("parent", None, [], selections)
            }
            pub fn select(nested_selections: Vec<note::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<note::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod comments {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "comments";
        pub struct Fetch(pub note::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<note::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: note::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: note::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Comments(v)
            }
        }
        pub fn fetch(params: Vec<note::WhereParam>) -> Fetch {
            Fetch(note::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<note::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectComments(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<note::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<note::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectComments(params)
        }
        pub fn set(params: Vec<note::UniqueWhereParam>) -> SetParam {
            SetParam::SetComments(params)
        }
        pub fn some(value: Vec<note::WhereParam>) -> WhereParam {
            WhereParam::CommentsSome(value)
        }
        pub fn every(value: Vec<note::WhereParam>) -> WhereParam {
            WhereParam::CommentsEvery(value)
        }
        pub fn none(value: Vec<note::WhereParam>) -> WhereParam {
            WhereParam::CommentsNone(value)
        }
        pub enum Include {
            Select(note::ManyArgs, Vec<note::SelectParam>),
            Include(note::ManyArgs, Vec<note::IncludeParam>),
            Fetch(note::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Comments(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <note::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <note::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: note::ManyArgs, nested_selections: Vec<note::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: note::ManyArgs,
                nested_selections: Vec<note::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(note::ManyArgs, Vec<note::SelectParam>),
            Include(note::ManyArgs, Vec<note::IncludeParam>),
            Fetch(note::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Comments(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <note::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(args: note::ManyArgs, nested_selections: Vec<note::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: note::ManyArgs,
                nested_selections: Vec<note::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        body: String,
        body_html: String,
        author: super::actor::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        super::actor::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (body, body_html, author, _params)
    }
    pub fn create_unchecked(
        body: String,
        body_html: String,
        author_id: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, Vec<SetParam>) {
        (body, body_html, author_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_note { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: note :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: note :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: note :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: note :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: note :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: note :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , body , body_html , author , author_id , parent_id , parent , comments } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: note :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: note :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: note :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: note :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: note :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: note :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "body" , "bodyHtml" , "author" , "authorId" , "parentId" , "parent" , "comments"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: note :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; body) => { String } ; (@ field_type ; body_html) => { String } ; (@ field_type ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { author :: Data } ; (@ field_type ; author) => { crate :: prisma :: actor :: Data } ; (@ field_type ; author_id) => { String } ; (@ field_type ; parent_id) => { Option < String > } ; (@ field_type ; parent : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < parent :: Data > } ; (@ field_type ; parent) => { Option < crate :: prisma :: note :: Data > } ; (@ field_type ; comments : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < comments :: Data > } ; (@ field_type ; comments) => { Vec < crate :: prisma :: note :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Note" , available relations are "id, body, body_html, author, author_id, parent_id, parent, comments")) } ; (@ field_module ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: actor :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; parent : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: note :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; comments : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: note :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: note :: SelectParam > :: into (crate :: prisma :: note :: id :: Select) } ; (@ selection_field_to_selection_param ; body) => { Into :: < crate :: prisma :: note :: SelectParam > :: into (crate :: prisma :: note :: body :: Select) } ; (@ selection_field_to_selection_param ; body_html) => { Into :: < crate :: prisma :: note :: SelectParam > :: into (crate :: prisma :: note :: body_html :: Select) } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: note :: SelectParam > :: into (crate :: prisma :: note :: author :: Select :: $ selection_mode (crate :: prisma :: actor :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: note :: SelectParam > :: into (crate :: prisma :: note :: author :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; author_id) => { Into :: < crate :: prisma :: note :: SelectParam > :: into (crate :: prisma :: note :: author_id :: Select) } ; (@ selection_field_to_selection_param ; parent_id) => { Into :: < crate :: prisma :: note :: SelectParam > :: into (crate :: prisma :: note :: parent_id :: Select) } ; (@ selection_field_to_selection_param ; parent $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: note :: SelectParam > :: into (crate :: prisma :: note :: parent :: Select :: $ selection_mode (crate :: prisma :: note :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; parent $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: note :: SelectParam > :: into (crate :: prisma :: note :: parent :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; comments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: note :: SelectParam > :: into (crate :: prisma :: note :: comments :: Select :: $ selection_mode (crate :: prisma :: note :: ManyArgs :: new (crate :: prisma :: note :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: note :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; comments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: note :: SelectParam > :: into (crate :: prisma :: note :: comments :: Select :: Fetch (crate :: prisma :: note :: ManyArgs :: new (crate :: prisma :: note :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: note :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; body) => { "body" } ; (@ field_serde_name ; body_html) => { "bodyHtml" } ; (@ field_serde_name ; author) => { "author" } ; (@ field_serde_name ; author_id) => { "authorId" } ; (@ field_serde_name ; parent_id) => { "parentId" } ; (@ field_serde_name ; parent) => { "parent" } ; (@ field_serde_name ; comments) => { "comments" } ; }
    pub use _select_note as select;
    pub enum SelectParam {
        Id(id::Select),
        Body(body::Select),
        BodyHtml(body_html::Select),
        Author(author::Select),
        AuthorId(author_id::Select),
        ParentId(parent_id::Select),
        Parent(parent::Select),
        Comments(comments::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Body(data) => data.to_selection(),
                Self::BodyHtml(data) => data.to_selection(),
                Self::Author(data) => data.to_selection(),
                Self::AuthorId(data) => data.to_selection(),
                Self::ParentId(data) => data.to_selection(),
                Self::Parent(data) => data.to_selection(),
                Self::Comments(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_note { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: note :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: note :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: note :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: note :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: note :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: note :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: note :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: note :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { author , parent , comments } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub body : String , pub body_html : String , pub author_id : String , pub parent_id : Option < String > , $ (pub $ field : crate :: prisma :: note :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (body) , stringify ! (body_html) , stringify ! (author_id) , stringify ! (parent_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: note :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: note :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: note :: body :: NAME , & self . body) ? ; state . serialize_field (crate :: prisma :: note :: body_html :: NAME , & self . body_html) ? ; state . serialize_field (crate :: prisma :: note :: author_id :: NAME , & self . author_id) ? ; state . serialize_field (crate :: prisma :: note :: parent_id :: NAME , & self . parent_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , body , body_html , author_id , parent_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: note :: $ field :: NAME) , + , crate :: prisma :: note :: id :: NAME , crate :: prisma :: note :: body :: NAME , crate :: prisma :: note :: body_html :: NAME , crate :: prisma :: note :: author_id :: NAME , crate :: prisma :: note :: parent_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: note :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: note :: id :: NAME => Ok (Field :: id) , crate :: prisma :: note :: body :: NAME => Ok (Field :: body) , crate :: prisma :: note :: body_html :: NAME => Ok (Field :: body_html) , crate :: prisma :: note :: author_id :: NAME => Ok (Field :: author_id) , crate :: prisma :: note :: parent_id :: NAME => Ok (Field :: parent_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut body = None ; let mut body_html = None ; let mut author_id = None ; let mut parent_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: note :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: body => { if body . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: note :: body :: NAME)) ; } body = Some (map . next_value () ?) ; } Field :: body_html => { if body_html . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: note :: body_html :: NAME)) ; } body_html = Some (map . next_value () ?) ; } Field :: author_id => { if author_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: note :: author_id :: NAME)) ; } author_id = Some (map . next_value () ?) ; } Field :: parent_id => { if parent_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: note :: parent_id :: NAME)) ; } parent_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: note :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: note :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: note :: id :: NAME)) ? ; let body = body . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: note :: body :: NAME)) ? ; let body_html = body_html . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: note :: body_html :: NAME)) ? ; let author_id = author_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: note :: author_id :: NAME)) ? ; let parent_id = parent_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: note :: parent_id :: NAME)) ? ; Ok (Data { id , body , body_html , author_id , parent_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "body" , "bodyHtml" , "author" , "authorId" , "parentId" , "parent" , "comments"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: note :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { author :: Data } ; (@ field_type ; author) => { crate :: prisma :: actor :: Data } ; (@ field_type ; parent : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < parent :: Data > } ; (@ field_type ; parent) => { Option < crate :: prisma :: note :: Data > } ; (@ field_type ; comments : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < comments :: Data > } ; (@ field_type ; comments) => { Vec < crate :: prisma :: note :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Note" , available relations are "author, parent, comments")) } ; (@ field_module ; author : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: actor :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; parent : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: note :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; comments : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: note :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: note :: IncludeParam > :: into (crate :: prisma :: note :: author :: Include :: $ selection_mode (crate :: prisma :: actor :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; author $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: note :: IncludeParam > :: into (crate :: prisma :: note :: author :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; parent $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: note :: IncludeParam > :: into (crate :: prisma :: note :: parent :: Include :: $ selection_mode (crate :: prisma :: note :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; parent $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: note :: IncludeParam > :: into (crate :: prisma :: note :: parent :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; comments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: note :: IncludeParam > :: into (crate :: prisma :: note :: comments :: Include :: $ selection_mode (crate :: prisma :: note :: ManyArgs :: new (crate :: prisma :: note :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: note :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; comments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: note :: IncludeParam > :: into (crate :: prisma :: note :: comments :: Include :: Fetch (crate :: prisma :: note :: ManyArgs :: new (crate :: prisma :: note :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: note :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; body) => { "body" } ; (@ field_serde_name ; body_html) => { "bodyHtml" } ; (@ field_serde_name ; author) => { "author" } ; (@ field_serde_name ; author_id) => { "authorId" } ; (@ field_serde_name ; parent_id) => { "parentId" } ; (@ field_serde_name ; parent) => { "parent" } ; (@ field_serde_name ; comments) => { "comments" } ; }
    pub use _include_note as include;
    pub enum IncludeParam {
        Id(id::Include),
        Body(body::Include),
        BodyHtml(body_html::Include),
        Author(author::Include),
        AuthorId(author_id::Include),
        ParentId(parent_id::Include),
        Parent(parent::Include),
        Comments(comments::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Body(data) => data.to_selection(),
                Self::BodyHtml(data) => data.to_selection(),
                Self::Author(data) => data.to_selection(),
                Self::AuthorId(data) => data.to_selection(),
                Self::ParentId(data) => data.to_selection(),
                Self::Parent(data) => data.to_selection(),
                Self::Comments(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_note { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: note struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "body")] pub body : String , # [serde (rename = "bodyHtml")] pub body_html : String , # [serde (rename = "authorId")] pub author_id : String , # [serde (rename = "parentId")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub parent_id : Option < String > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_note as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "body")]
        pub body: String,
        #[serde(rename = "bodyHtml")]
        pub body_html: String,
        #[serde(rename = "author")]
        pub author: Option<Box<super::actor::Data>>,
        #[serde(rename = "authorId")]
        pub author_id: String,
        #[serde(rename = "parentId")]
        pub parent_id: Option<String>,
        #[serde(
            rename = "parent",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub parent: Option<Option<Box<super::note::Data>>>,
        #[serde(rename = "comments")]
        pub comments: Option<Vec<super::note::Data>>,
    }
    impl Data {
        pub fn author(
            &self,
        ) -> Result<&super::actor::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.author
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(author),
                ))
                .map(|v| v.as_ref())
        }
        pub fn parent(
            &self,
        ) -> Result<Option<&super::note::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.parent
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(parent),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn comments(
            &self,
        ) -> Result<&Vec<super::note::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.comments
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(comments),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Author(super::actor::UniqueArgs),
        Parent(super::note::UniqueArgs),
        Comments(super::note::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Author(args) => {
                    let mut selections = < super :: actor :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(author::NAME, None, [], selections)
                }
                Self::Parent(args) => {
                    let mut selections =
                        <super::note::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(parent::NAME, None, [], selections)
                }
                Self::Comments(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(
                        <super::note::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    );
                    ::prisma_client_rust::Selection::new(
                        comments::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetBody(String),
        SetBodyHtml(String),
        ConnectAuthor(super::actor::UniqueWhereParam),
        SetAuthorId(String),
        SetParentId(Option<String>),
        ConnectParent(super::note::UniqueWhereParam),
        DisconnectParent,
        ConnectComments(Vec<super::note::UniqueWhereParam>),
        DisconnectComments(Vec<super::note::UniqueWhereParam>),
        SetComments(Vec<super::note::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetBody(value) => (
                    body::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetBodyHtml(value) => (
                    body_html::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectAuthor(where_param) => (
                    author::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::actor::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetAuthorId(value) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetParentId(value) => (
                    parent_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::ConnectParent(where_param) => (
                    parent::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::note::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectParent => (
                    parent::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::ConnectComments(where_params) => (
                    comments::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::note::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectComments(where_params) => (
                    comments::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::note::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetComments(where_params) => (
                    comments::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::note::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        Body(String),
        BodyHtml(String),
        AuthorId(String),
        ParentId(Option<String>),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Body(value) => Self::SetBody(value),
                UncheckedSetParam::BodyHtml(value) => Self::SetBodyHtml(value),
                UncheckedSetParam::AuthorId(value) => Self::SetAuthorId(value),
                UncheckedSetParam::ParentId(value) => Self::SetParentId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Body(::prisma_client_rust::Direction),
        BodyHtml(::prisma_client_rust::Direction),
        AuthorId(::prisma_client_rust::Direction),
        ParentId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Body(direction) => (
                    body::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::BodyHtml(direction) => (
                    body_html::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::AuthorId(direction) => (
                    author_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ParentId(direction) => (
                    parent_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        Body(_prisma::read_filters::StringFilter),
        BodyHtml(_prisma::read_filters::StringFilter),
        AuthorIs(Vec<super::actor::WhereParam>),
        AuthorIsNot(Vec<super::actor::WhereParam>),
        AuthorId(_prisma::read_filters::StringFilter),
        ParentId(_prisma::read_filters::StringNullableFilter),
        ParentIsNull,
        ParentIs(Vec<super::note::WhereParam>),
        ParentIsNot(Vec<super::note::WhereParam>),
        CommentsSome(Vec<super::note::WhereParam>),
        CommentsEvery(Vec<super::note::WhereParam>),
        CommentsNone(Vec<super::note::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Body(value) => (body::NAME, value.into()),
                Self::BodyHtml(value) => (body_html::NAME, value.into()),
                Self::AuthorIs(where_params) => (
                    author::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuthorIsNot(where_params) => (
                    author::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AuthorId(value) => (author_id::NAME, value.into()),
                Self::ParentId(value) => (parent_id::NAME, value.into()),
                Self::ParentIsNull => (
                    parent::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::ParentIs(where_params) => (
                    parent::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ParentIsNot(where_params) => (
                    parent::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::CommentsSome(where_params) => (
                    comments::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::CommentsEvery(where_params) => (
                    comments::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::CommentsNone(where_params) => (
                    comments::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(body::NAME),
                ::prisma_client_rust::sel(body_html::NAME),
                ::prisma_client_rust::sel(author_id::NAME),
                ::prisma_client_rust::sel(parent_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            body: String,
            body_html: String,
            author: super::actor::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                body::set(body),
                body_html::set(body_html),
                author::connect(author),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            body: String,
            body_html: String,
            author_id: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                body::set(body),
                body_html::set(body_html),
                author_id::set(author_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(body, body_html, author_id, mut _params)| {
                    _params.extend([
                        body::set(body),
                        body_html::set(body_html),
                        author_id::set(author_id),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (body, body_html, author, mut _params): (
                String,
                String,
                super::actor::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                body::set(body),
                body_html::set(body_html),
                author::connect(author),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod _prisma {
    pub struct PrismaClientBuilder {
        url: Option<String>,
        action_notifier: ::prisma_client_rust::ActionNotifier,
    }
    impl PrismaClientBuilder {
        fn new() -> Self {
            Self {
                url: None,
                action_notifier: ::prisma_client_rust::ActionNotifier::new(),
            }
        }
        pub fn with_url(mut self, url: String) -> Self {
            self.url = Some(url);
            self
        }
        pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
            let internals = ::prisma_client_rust::PrismaClientInternals::new(
                self.url,
                self.action_notifier,
                super::DATAMODEL_STR,
            )
            .await?;
            Ok(PrismaClient(internals))
        }
    }
    pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub fn _builder() -> PrismaClientBuilder {
            PrismaClientBuilder::new()
        }
        pub fn _run_command_raw<T: ::prisma_client_rust::Data>(
            &self,
            command: ::prisma_client_rust::serde_json::Value,
        ) -> ::prisma_client_rust::RunCommandRaw<T> {
            ::prisma_client_rust::RunCommandRaw::new(&self.0, command)
        }
        pub async fn _batch<
            'batch,
            T: ::prisma_client_rust::BatchContainer<'batch, Marker>,
            Marker,
        >(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::Result<
            <T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
        > {
            ::prisma_client_rust::batch(queries, &self.0).await
        }
        pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
            ::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
        }
        pub fn domain(&self) -> super::domain::Actions {
            super::domain::Actions { client: &self.0 }
        }
        pub fn actor(&self) -> super::actor::Actions {
            super::actor::Actions { client: &self.0 }
        }
        pub fn note(&self) -> super::note::Actions {
            super::note::Actions { client: &self.0 }
        }
    }
    impl ::prisma_client_rust::PrismaClient for PrismaClient {
        fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
            &self.0
        }
        fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
            &mut self.0
        }
        fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
            Self(self.0.with_tx_id(tx_id))
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum ActorScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "displayName")]
        DisplayName,
        #[serde(rename = "domainId")]
        DomainId,
    }
    impl ToString for ActorScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::DisplayName => "displayName".to_string(),
                Self::DomainId => "domainId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum DomainScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "dnsName")]
        DnsName,
        #[serde(rename = "applications")]
        Applications,
    }
    impl ToString for DomainScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::DnsName => "dnsName".to_string(),
                Self::Applications => "applications".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum NoteScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "body")]
        Body,
        #[serde(rename = "bodyHtml")]
        BodyHtml,
        #[serde(rename = "authorId")]
        AuthorId,
        #[serde(rename = "parentId")]
        ParentId,
    }
    impl ToString for NoteScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Body => "body".to_string(),
                Self::BodyHtml => "bodyHtml".to_string(),
                Self::AuthorId => "authorId".to_string(),
                Self::ParentId => "parentId".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    pub mod read_filters {
        #[derive(Clone)]
        pub enum StringListFilter {
            Equals(Vec<String>),
            Has(Option<String>),
            HasEvery(Vec<String>),
            HasSome(Vec<String>),
            IsEmpty(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringListFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Has(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "has".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                    Self::HasEvery(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "hasEvery".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::HasSome(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "hasSome".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::IsEmpty(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "isEmpty".to_string(),
                            ::prisma_client_rust::PrismaValue::Boolean(value),
                        )])
                    }
                }
            }
        }
        #[derive(Clone)]
        pub enum StringFilter {
            Equals(String),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(String),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum StringNullableFilter {
            Equals(Option<String>),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(Option<String>),
            IsSet(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                    Self::IsSet(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "isSet".to_string(),
                            ::prisma_client_rust::PrismaValue::Boolean(value),
                        )])
                    }
                }
            }
        }
    }
}
pub use _prisma::*;
